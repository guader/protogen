package main

import (
	"flag"

	"google.golang.org/protobuf/compiler/protogen"
)

var (
	flags       flag.FlagSet
	optEnumName string
)

func main() {
	flags.StringVar(&optEnumName, "enum_name", "", "generate codes for enums by the name")
	protogen.Options{ParamFunc: flags.Set}.Run(generate)
}

func generate(plugin *protogen.Plugin) error {
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}
		if skipFile(file) {
			continue
		}

		g := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".err.go", file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-err. DO NOT EDIT.")
		g.P("package ", file.GoPackageName)
		g.P()
		g.P("import (")
		g.P(`codes "google.golang.org/grpc/codes"`)
		g.P(`status "google.golang.org/grpc/status"`)
		g.P(")")
		g.P()

		for _, enum := range file.Enums {
			if skipEnum(enum) {
				continue
			}
			// implement error interface
			g.P("func (x ", enum.Desc.Name(), ") Error() string {")
			g.P("return x.String()")
			g.P("}")
			g.P()
			// grpc codes and status
			g.P("func (x ", enum.Desc.Name(), ") Err() error {")
			g.P("return status.Error(codes.Code(x), x.Error())")
			g.P("}")
			g.P()
			g.P("func (x ", enum.Desc.Name(), ") ErrWithMsg(msg string) error {")
			g.P("return status.Error(codes.Code(x), msg)")
			g.P("}")
			g.P()
		}
	}
	return nil
}

func skipEnum(enum *protogen.Enum) bool {
	// do not skip if enum name is not specified
	if len(optEnumName) == 0 {
		return false
	}
	return string(enum.Desc.Name()) != optEnumName
}

func skipFile(file *protogen.File) bool {
	// do not skip if enum name is not specified
	if len(optEnumName) == 0 {
		return false
	}
	for _, e := range file.Enums {
		if !skipEnum(e) {
			return false
		}
	}
	return true
}
